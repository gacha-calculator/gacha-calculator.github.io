import{q as j,t as q,I as w}from"./solvers-Cgo-6Fxx.js";function ft(t){const{cashbackCalculator:r,uiUpdater:e}=t;return function(a){const{results:n,inputConfig:i,chartLabels:l,gachaConfig:p,CONSTELLATION_MAP:s}=a,c=r(i,p,n.cashbackData.SSR,n.cashbackData.CharSR,n.cashbackData.WepSR,i.SR.rateUps,s);e(n.cashbackData.SSR,l,c)}}class ut{constructor(r,e={}){this.config=r,this.adapters={statesLimits:null,distributionArrays:{makeSSR:()=>{throw new Error("makeSSR not implemented")},makeSR:()=>{throw new Error("makeSR not implemented")},sortPity:()=>{throw new Error("sortPity not implemented")}},pullLogic:{rankUpSSRCheap:()=>{throw new Error("rankUpSSRCheap not implemented")}},workers:{ssrWorker:()=>{throw new Error("ssrWorker not implemented")},srWorker:()=>{throw new Error("srWorker not implemented")}},contexts:{contextSSR:()=>{throw new Error("contextSSR not implemented")},contextSR:()=>{throw new Error("contextSR not implemented")}},helpers:{consolidateDistributionForCashback:()=>{throw new Error("consolidateDistributionForCashback not implemented")},consolidateProbabilitiesCheap:()=>{throw new Error("consolidateProbabilitiesCheap not implemented")},simplifyDistribution:()=>{throw new Error("simplifyDistribution not implemented")},normalizeCheap:()=>{throw new Error("normalizeCheap not implemented")},checkIsEmpty:()=>{throw new Error("checkIsEmpty not implemented")}},...e}}async runGachaCalculation(r,e){this.adapters.contexts.contextSSR.target=e;let o=[],a={},n=!1,i=!1;const{ssrWorker:l,srWorker:p}=this.adapters.workerManager.getWorkers(),s=this.adapters.distributionArrays.sortPity(r);this.adapters.contexts.contextSSR.pities=s;let{distributionSSR:c}=this.adapters.distributionArrays.makeSSR(r,s),{distributionCharSR:f,distributionWepSR:h}=this.adapters.distributionArrays.makeSR(r);try{await z(l,p,this.adapters.contexts,c,{distributionCharSR:f,distributionWepSR:h},s)}catch(m){console.error("Failed to initialize workers:",m)}let u=await M(l);for(u.type==="IterationComplete"?a=u.lossData:(a=u.lossData,n=u.isTarget,i=u.isEmpty,o=u.allPullsDistributionSSR,c=u.distributionSSR);!i&&!n;)[u]=await Promise.all([M(l),F(p,a)]),u.type==="IterationComplete"?a=u.lossData:(a=u.lossData,n=u.isTarget,i=u.isEmpty,o=u.allPullsDistributionSSR,c=u.distributionSSR);let k=await N(p,a);this.adapters.workerManager.terminateWorkers(),f=k.distributionCharSR,h=k.distributionWepSR;const y={SSR:this.adapters.helpers.consolidateDistributionForCashback(c),CharSR:this.adapters.helpers.consolidateDistributionForCashback(f),WepSR:this.adapters.helpers.consolidateDistributionForCashback(h)};this.adapters.helpers.simplifyDistribution(c),f=null,h=null;let D=0;const B=10;for(;!i;)n&&(D++,this.adapters.pullLogic.rankUpSSRCheap(c,s),D===B&&this.adapters.helpers.normalizeCheap(c),o.push(this.adapters.helpers.consolidateProbabilitiesCheap(c)),i=this.adapters.helpers.checkIsEmpty(c,n));return{chartData:o,cashbackData:y};async function z(m,b,C,R,{distributionCharSR:d,distributionWepSR:H}){return new Promise((K,V)=>{let v=!1,g=!1,W=!1;function I(){!W&&v&&g&&K()}function O(S){W||(W=!0,V(S))}m.onerror=S=>{console.error("Worker error:",S),O(S)},b.onerror=S=>{O(S)},m.onmessage=function(S){switch(S.data.type){case"InitComplete":v=!0,I();break;default:console.warn("Unknown message type")}},b.onmessage=function(S){switch(S.data.type){case"InitComplete":g=!0,I();break;default:console.warn("Unknown message type")}},m.postMessage({type:"Initiate",distribution:R,context:C}),b.postMessage({type:"Initiate",distribution:{distributionCharSR:d,distributionWepSR:H},context:C})})}function M(m){return new Promise((b,C)=>{m.onmessage=R=>{switch(R.data.type){case"IterationComplete":b(R.data);break;case"LastIteration":b(R.data);break}},m.onerror=C,m.postMessage({type:"Iterate"})})}function F(m,b){return new Promise((C,R)=>{m.onmessage=d=>{C()},m.onerror=R,m.postMessage({type:"Iterate",lossData:b})})}function N(m,b){return new Promise((C,R)=>{m.onmessage=d=>{C(d.data)},m.onerror=R,m.postMessage({type:"IterateLast",lossData:b})})}}}function Y(t){return new Worker("/assets/ssr-worker-D4YCWSXa.js",{type:"module",name:t?.name})}function G(t){return new Worker("/assets/sr-worker-Bs6jCU2D.js",{type:"module",name:t?.name})}class mt{constructor(){this.ssrWorker=null,this.srWorker=null}getWorkers(){return this.ssrWorker||(this.ssrWorker=new Y),this.srWorker||(this.srWorker=new G),{ssrWorker:this.ssrWorker,srWorker:this.srWorker}}terminateWorkers(){this.ssrWorker&&this.ssrWorker.terminate(),this.srWorker&&this.srWorker.terminate(),this.ssrWorker=null,this.srWorker=null}}class U{constructor(r,e,o){this.rateUps=r,this.offRates=e,this.probability=o}}function $(t,r,e){const o=[],a=new Array(e).fill(0);function n(i,l){if(i===e){if(l===r){const s=P(a,t);o.push(new U([...a],s))}return}const p=Math.min(t[i],r-l);for(let s=0;s<=p;s++)a[i]=s,n(i+1,l+s),a[i]=0}return n(0,0),o}function P(t,r){const e=[...r];for(let o=0;o<t.length;o++)e[o]-=t[o];return e}function X(t,r,e){const o=new Array(Object.keys(e).length).fill(0);for(const a of r)if(a==="new")t[0]++,o[0]++;else{const n=e[a];n!==void 0?o[n]++:console.warn(`Invalid or unhandled rate-up value found: "${selectedValue}"`)}return o}function J(t,r,e){const o=t.length,a=e.reduce((s,c)=>s+c,0),n=r-a;if(n<0)return console.error("Error: More items are known than the total required."),[];const i=new Array(o);for(let s=0;s<o;s++)if(i[s]=t[s]-e[s],i[s]<0)return console.error(`Error: Known picks for constellation ${s} exceed its capacity.`),[];return $(i,n,o).map(s=>{const c=s.rateUps.map((h,u)=>h+e[u]),f=P(c,t);return new U(c,f)})}function Q(t,r,e){const o=r.map((i,l)=>i-e[l]),a=new Map;for(const i of t){const l=i.rateUps.map((s,c)=>s-e[c]);if(l.some(s=>s<0)){i.probability=0;continue}const p=new U(l,[]);a.set(p,i)}const n=Array.from(a.keys());n.length>0&&j(n,o);for(const[i,l]of a.entries())l.probability=i.probability}function A(t,r,e,o){return Array.from({length:t+1},(a,n)=>{const i=q(n,o);let l=0,p=0;for(let s=0;s<=n;s++){const c=n-s,f=r[s],h=c*e,u=f.mean+h,k=f.variance+Math.pow(u,2);l+=u*i[s],p+=k*i[s]}return{mean:l,variance:Math.max(0,p-Math.pow(l,2))}})}function Z(t,r,e,o){let a=r[t.rateUpCount],n=e[t.charOffRateCount],i=t.wepOffRateCount*o;return{mean:a+n.mean+i,variance:n.variance}}function tt(t){const e=Math.sqrt(t.variance),o=1/Math.sqrt(.2);let a=t.mean-e*o;a<0&&(a=0);const n=t.mean+e*o,i=t.mean;return{LOWER_BOUND:a,MEAN:i,UPPER_BOUND:n}}function et(t,r){const e=[];let o=0;for(let a=0;a<t.length;a++)for(const[n,i]of t[a].offRates.entries()){const l=Math.floor(n/100);i.prob>r&&(e.push({rateUpCount:a,charOffRateCount:l,wepOffRateCount:n%100,probability:i.prob}),o=Math.max(o,l))}return{combos:e,maxOffRateCount:o}}function x(t,r){const e=[];let o=0;for(let a=0;a<t.length;a++)for(const[n,i]of t[a].offRates.entries())i.prob>r&&(e.push({rateUpCount:a,offRateCount:n,probability:i.prob}),o=Math.max(o,n));return{combos:e,maxOffRateCount:o}}function T(t,r,e){let o=0,a=0;for(const{rateUpCount:n,offRateCount:i,probability:l}of t){const p=r[n],s=e[i],c=p.mean+s.mean,f=p.variance+s.variance+Math.pow(c,2);o+=l*c,a+=l*f}return{mean:o,variance:Math.max(0,a-Math.pow(o,2))}}function _(t){let r=0,e=0;for(const{probability:o,cashback:a}of t)r+=o*a.mean;for(const{probability:o,cashback:a}of t){const n=a.variance+Math.pow(a.mean,2);e+=o*n}return{mean:r,variance:Math.max(0,e-Math.pow(r,2))}}function ot(...t){return t.reduce((r,e)=>({mean:r.mean+e.mean,variance:r.variance+e.variance}),{mean:0,variance:0})}const L=.5,E=1e-8;function ht(t,r,e,o,a,n,i){e=at(e),n=X(t.SR.consCount,n,i);const l=J(t.SR.consCount,r.rateUpCharacterSR,n);Q(l,t.SR.consCount,n);const p=rt(e,r.poolStandardCharSSR,t.SSR.consCountStandard,t.SSR.cashbackRoadmap,r),s=nt(l,o,a,r,t),c=p;for(let f=0;f<c.length;f++)c[f].mean+=s.mean,c[f].variance+=s.variance,c[f]=tt(c[f]);return c}function at(t){let r=0;for(const e of t)for(const[o,a]of e.offRates)r+=a.prob;for(const e of t)for(const[o,a]of e.offRates)a.prob/=r;return t}function rt(t,r,e,o,a){const{combos:n,maxOffRateCount:i}=et(t,E),l=[0];let p=0;for(let c=0;c<t.length;c++)o[c-1]==="none"?l.push(p):o[c-1]==="regular"&&(p+=a.configSSR.regularPoints,l.push(p));const s=Array.from({length:t.length},()=>[]);for(const c of n){const f=c.rateUpCount,h=c.probability,k=new w(e,r,a.configSSR).runSteps(i),y=Z(c,l,k,a.configWep.pointsSSR);s[f].push({cashback:y,probability:h})}for(let c=0;c<s.length;c++){const f=ct(s[c]);s[c]=_(f)}return s}function nt(t,r,e,o,a){const{combos:n,maxOffRateCount:i}=x(r,E),{combos:l,maxOffRateCount:p}=x(e,E),s=st(t,n,i,o),c=it(l,p,o,a);return ot(s,c)}function st(t,r,e,o){const a=Math.max(...r.map(i=>i.rateUpCount)),n=[];for(const{rateUps:i,offRates:l,probability:p}of t){const c=new w(i,o.rateUpCharacterSR,o.configSR).runSteps(a),h=new w(l,o.poolCharSR-o.rateUpCharacterSR,o.configSR).runSteps(e),u=A(e,h,o.configWep.pointsSR,L),k=T(r,c,u);n.push({probability:p,cashback:k})}return _(n)}function it(t,r,e,o){const a=Math.max(...t.map(c=>c.rateUpCount)),n=s(a,e.configWep.pointsSR),l=new w(o.SR.consCount,e.poolCharSR,e.configSR).runSteps(r),p=A(r,l,e.configWep.pointsSR,L);return T(t,n,p);function s(c,f){return Array.from({length:c+1},(h,u)=>({mean:u*f,variance:0}))}}function ct(t){let r=0;for(const e of t)r+=e.probability;for(const e of t)e.probability/=r;return t}export{mt as W,ht as a,ft as c,ut as g};

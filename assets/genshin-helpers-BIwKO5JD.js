function R(t){let e=0;if(Array.isArray(t[0])){for(const o of t)for(let s=0;s<4;s++){const f=o[s].states;for(const l of f)for(const[p,u]of l)e+=u.prob,u.prob<=1e-10&&l.delete(p)}if(Math.abs(e-1)>1e-5){const o=1/e;for(const s of t)for(let f=0;f<4;f++){const l=s[f].states;for(const p of l)for(const[u,i]of p)i.prob*=o}}}else{for(const o of t){const s=o.states;for(const f of s)for(const[l,p]of f)e+=p.prob,p.prob<=1e-10&&f.delete(l)}if(Math.abs(e-1)>1e-5){const o=1/e;for(const s of t){const f=s.states;for(const l of f)for(const[p,u]of l)u.prob*=o}}}}function h(t,r){let c=!0;const n=4;if(r)for(let e=0;e<t.length-1;e++){let a=!0;for(let o=0;o<n;o++){for(const s of t[e][o].states)s>0&&(a=!1,c=!1);t[e][o].isEmpty=a}t[e].isEmpty=a}else for(let e=0;e<t.length-1;e++){let a=!0;for(let o=0;o<n;o++){for(const s of t[e][o].states)s.size>0&&(a=!1,c=!1);t[e][o].isEmpty=a}t[e].isEmpty=a}return c}function m(t){const r=[];if(Array.isArray(t[0]))for(let e=0;e<t.length;e++){let a="None";e>0&&e<=t.length&&t[e-1]&&(a=t[e-1][0].type||"None");let o={offRates:new Map,type:a};for(let s=0;s<4;s++){const f=t[e][s].states;for(const l of f)l.size>0&&c(o.offRates,l)}r.push(o)}else for(let n=0;n<t.length;n++){const e=t[n].states;let a="None";n>0&&n<=t.length&&t[n-1]&&(a=t[n-1].type||"None");let o={offRates:new Map,type:a};for(const s of e)s.size>0&&c(o.offRates,s);r.push(o)}return r;function c(n,e){for(const[a,o]of e)n.has(a)?n.get(a).prob+=o.prob:n.set(a,{...o})}}function y(t){const r=new Array(t.length),c=4;for(let n=0;n<t.length;n++){let e=0;for(let a=0;a<c;a++){const o=t[n][a].states;for(let s=0;s<o.length;s++)e+=o[s]}r[n]=e}return r}function E(t){const r=[];for(let c=0;c<t.length;c++){const n=t[c];let e=0;for(let a=0;a<n.length;a++){const o=n[a].states;for(let s=0;s<o.length;s++)for(const[f,l]of o[s])e+=l.prob}r.push(e)}return r}function M(t){let n=0;for(let e=0,a=t.length;e<a;e++)for(let o=0;o<4;o++){const s=t[e][o].states;for(let f=0,l=s.length;f<l;f++)s[f]>0&&s[f]<=1e-10&&(n+=s[f],s[f]=0)}if(n>0){const e=1/(1-n);for(let a=0,o=t.length;a<o;a++)for(let s=0;s<4;s++){const f=t[a][s].states;for(let l=0,p=f.length;l<p;l++)f[l]!=0&&(f[l]*=e)}}}function d(t){for(let c=0;c<t.length;c++)for(let n=0;n<4;n++){const e=t[c][n].states;for(let a=0;a<e.length;a++){const o=e[a];let s=0;for(const f of o.values())s+=f.prob;e[a]=s}}}function L(t,r,c){if(r.type==="probability"){const n=t.length-1,e=t[n];let a=0;for(let o=0;o<e.length;o++)for(const s of e[o].states)for(const[f,l]of s)a+=l.prob;return a>r.value}else if(r.type==="pulls")return c===r.value}export{h as checkIsEmpty,L as checkIsTarget,m as consolidateDistributionForCashback,E as consolidateProbabilities,y as consolidateProbabilitiesCheap,M as normalizeCheap,R as pruneAndNormalize,d as simplifyDistribution};

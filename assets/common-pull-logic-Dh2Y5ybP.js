function M(r,a,o,l,c,p,u){const{charPullsSum:U,wepPullsSum:g}=h(r),f={characters:0,weapons:0},i={},L=r.length-2;for(let s=L;s>=0;s--){const e=r[s],t=p[s+1];if(!e.isEmpty)if(e.type==="Character")N(a,s,r,l,f,e.type,t,u);else if(e.type==="Weapon")N(o,s,r,c,f,e.type,t,u);else throw new Error(`Unknown SSR array type: ${e.type}`)}const{charRankUps:w,wepRankUps:E}=P(U,g,f);return i.charRankUps=w,i.wepRankUps=E,i;function h(s){const e={charPullsSum:0,wepPullsSum:0};if(s.length<=1)return e;const t=s.length-1;for(let n=0;n<t;n++){const{type:b,states:S}=s[n];let R=0;for(const m of S)for(const{prob:k}of m.values())R+=k;switch(b){case"Character":e.charPullsSum+=R;break;case"Weapon":e.wepPullsSum+=R;break}}return e}function P(s,e,t){let n=t.characters,b=t.weapons;return{charRankUps:{pullsSum:s,rankUps:n},wepRankUps:{pullsSum:e,rankUps:b}}}}function C(r,a,o,l){const c=r.length-1;for(let p=c;p>=0;p--)r[p].isEmpty||O(o,p,r,l,a)}function v(r,a,o,l,c,p,u){const U=r.length-2;for(let g=U;g>=0;g--){const f=r[g],i=u[g+1];if(!f.isEmpty)if(f.type==="Character")V(a,g,r,l,f.type,i,p);else if(f.type==="Weapon")V(o,g,r,c,f.type,i,p);else throw new Error(`Unknown SSR array type: ${f.type}`)}}function N(r,a,o,l,c,p,u,U){const g=o[a].states.length,f=U.rateUpOddsChar,i=U.rateUpOddsWep;let L=.5;p==="Character"?L=f:p==="Weapon"&&(L=i);const w=o[a].states,E=o[a+1].states;for(let h=g-1;h>=0;h--){const P=w[h],s=h>=l,e=r[h-l*s];for(const[t,n]of P){const b=n.prob*e,S=n.prob-b;let R=b;if(R>1e-10){s||(R*=L);const k=E[u],d=k.get(t);d?d.prob+=R:k.set(t,{prob:R}),p==="Character"?c.characters+=R:p==="Weapon"&&(c.weapons+=R)}if(!s){let k=b*(1-L);if(k>1e-10){let d=t;p==="Character"?d+=100:p==="Weapon"&&d++;const y=w[l],W=y.get(d);W?W.prob+=k:y.set(d,{prob:k})}}let m=S;if(m>1e-10){const k=w[h+1],d=k.get(t);d?d.prob+=m:k.set(t,{prob:m})}n.prob=0}}}function O(r,a,o,l,c){const p=o[a].states.length,u=o[a].states;c.rankUpFail=c.pullsSum-c.rankUps;for(let U=p-1;U>=0;U--){const g=u[U],f=U>=l,i=r[U-l*f],L=.5;for(const[w,E]of g){const h=E.prob,P=h*c.pullsSum;if(P>1e-10){E.prob=h*(1-c.pullsSum);const s=h*i*c.rankUpFail,e=P*(1-i)+h*i*c.rankUps;if(s>1e-10){let t=s;f||(t*=L),o[a+1]===void 0&&(o[a+1]={states:Array.from({length:o[a].states.length},()=>new Map)});const n=o[a+1].states[0],b=n.get(w);b?b.prob+=t:n.set(w,{prob:t})}if(!f){let t=s*(1-L);if(t>1e-10){let n=w+1;const b=u[l],S=b.get(n);S?S.prob+=t:b.set(n,{prob:t})}}if(e>1e-10)if(U-l*f===l-1)E.prob+=P*i*c.rankUps;else{const t=u[U+1],n=t.get(w);n?n.prob+=e:t.set(w,{prob:e})}}}}}function V(r,a,o,l,c,p,u){const U=o[a].states.length,g=u.rateUpOddsChar,f=u.rateUpOddsWep;let i=.5;c==="Character"?i=g:c==="Weapon"&&(i=f);const L=o[a].states,w=o[a+1].states;for(let E=U-1;E>=0;E--){const h=L[E],P=E>=l,s=r[E-l*P],e=h*s,t=h-e;let n=e;if(n>1e-10&&(P||(n*=i),w[p]+=n),!P){let S=e*(1-i);S>1e-10&&(L[l]+=S)}let b=t;b>1e-10&&(L[E+1]+=b),L[E]=0}}export{C as rankUpSR,M as rankUpSSR,v as rankUpSSRCheap};

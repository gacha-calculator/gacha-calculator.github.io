function P(e){const o=new Array(e.length);for(let a=0;a<e.length;a++){let t=0;const n=e[a].states;for(let s=0;s<n.length;s++){const r=n[s];for(const l of r.values())t+=l.prob}o[a]=t}return o}function C(e){const o=new Array(e.length);for(let a=0;a<e.length;a++){let t=0;const n=e[a].states;for(let s=0;s<n.length;s++)t+=n[s];o[a]=t}return o}function W(e){let a=0;for(let t=0,n=e.length;t<n;t++){const s=e[t].states;for(let r=0,l=s.length;r<l;r++)s[r]>0&&s[r]<=1e-10&&(a+=s[r],s[r]=0)}if(a>0){const t=1/(1-a);for(let n=0,s=e.length;n<s;n++){const r=e[n].states;for(let l=0,c=r.length;l<c;l++)r[l]!=0&&(r[l]*=t)}}}function d(e,o){let a=!0;if(o)for(let t=0;t<e.length-1;t++){let n=!0;for(const s of e[t].states)s>0&&(n=!1,a=!1);e[t].isEmpty=n}else for(let t=0;t<e.length-1;t++){let n=!0;for(const s of e[t].states)s.size>0&&(n=!1,a=!1);e[t].isEmpty=n}return a}function U(e){const o=[];for(let t=0;t<e.length;t++){const n=e[t].states;let s="None";t>0&&t<=e.length&&e[t-1]&&(s=e[t-1].type||"None");let r={offRates:new Map,type:s};for(const l of n)l.size>0&&a(r.offRates,l);o.push(r)}return o;function a(t,n){for(const[s,r]of n)t.has(s)?t.get(s).prob+=r.prob:t.set(s,{...r})}}function N(e){for(let o=0;o<e.length;o++){const a=e[o].states;for(let t=0;t<a.length;t++){const n=a[t];let s=0;for(const r of n.values())s+=r.prob;a[t]=s}}}function k(e,o,a){if(!Array.isArray(e.SSR.pullPlan))throw new Error("Invalid pull plan");const t={CHARACTER:0},{pullPlan:n}=e.SSR,s=[];for(const[l,c]of n.entries())c===t.CHARACTER?s.push({states:Array.from({length:a.CHARACTER},()=>new Map),type:"Character",isEmpty:!0}):s.push({states:Array.from({length:a.WEAPON},()=>new Map),type:"Weapon",isEmpty:!0});return s.push({states:Array.from({length:1},()=>new Map)}),r(o),{distributionSSR:s};function r(l){s[0].states[l[0]].set(0,{prob:1}),s[0].isEmpty=!1}}function v(e,o){const a=o.pitySSRChar,t=o.pitySSRWep;let n=!1,s=!1,r=0,l=0;const c=[];r+=e.SSR.pity.char,r+=e.SSR.guarantee.char*a,l+=e.SSR.pity.wep,l+=e.SSR.guarantee.wep*t;for(const f of e.SSR.pullPlan)f==0&&!n?(n=!0,c.push(r)):f==1&&!s?(s=!0,c.push(l)):c.push(0);return c.push(0),c}function L(e,o){const t=(o.SR-1)/2,n=[{states:Array.from({length:o.SR},()=>new Map)}],s=[{states:Array.from({length:o.SR},()=>new Map)}],r=e.SR.guarantee.char*t+e.SR.pity.char,l=e.SR.guarantee.wep*t+e.SR.pity.wep;c(n[0].states[r]),c(s[0].states[l]);function c(f){f.set(0,{prob:1})}return{distributionCharSR:n,distributionWepSR:s}}const u=1e-10;function z(e,o,a,t,n,s){const r=e.length-2;for(let l=r;l>=0;l--){const c=e[l],f=s[l+1];if(!c.isEmpty)if(c.type==="Character")w(o,l,e,t,c.type,f);else if(c.type==="Weapon")w(a,l,e,n,c.type,f);else throw new Error(`Unknown SSR array type: ${c.type}`)}}function w(e,o,a,t,n,s){const r=a[o].states.length,l=.5,c=.75;let f=.5;n==="Character"?f=l:n==="Weapon"&&(f=c);const i=a[o].states,A=a[o+1].states;for(let p=r-1;p>=0;p--){const R=i[p],h=p>=t,b=e[p-t*h],y=R*b,g=R-y;let S=y;if(S>u&&(h||(S*=f),A[s]+=S),!h){let E=y*(1-f);E>u&&(i[t]+=E)}let m=g;m>u&&(i[p+1]+=m),i[p]=0}}export{P as a,C as b,d as c,U as d,v as e,k as f,L as m,W as n,z as r,N as s};

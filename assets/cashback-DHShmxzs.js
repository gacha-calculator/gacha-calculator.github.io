import{p as W,a as x,b as I,d as O,e as A,f as P,h as k,i as C,j as B,k as i,l as v}from"./cashback-helpers-CihShbmN.js";import{A as m}from"./solvers-3q-h4Lr5.js";const U=.5,h=1e-8;function D(a,e,t,s,n,c,R){t=w(t),c=W(a.SR.consCount,c,R);const l=x(a.SR.consCount,e.rateUpCharacterSR,c);I(l,a.SR.consCount,c);const b=_(t,e.poolStandardCharSSR,a.SSR.consCountStandard,a.SSR.cashbackRoadmap,e),r=d(l,s,n,e,a),o=b;for(let f=0;f<o.length;f++)o[f].mean+=r.mean,o[f].variance+=r.variance,o[f]=O(o[f]);return o}function w(a){let e=0;for(const t of a)for(const[s,n]of t.offRates)e+=n.prob;for(const t of a)for(const[s,n]of t.offRates)n.prob/=e;return a}function _(a,e,t,s,n){const{combos:c,maxOffRateCount:R}=A(a,h),l=[0];let b=0;for(let o=0;o<a.length;o++)s[o-1]==="none"?l.push(b):s[o-1]==="regular"&&(b+=n.configSSR.regularPoints,l.push(b));const r=Array.from({length:a.length},()=>[]);for(const o of c){const f=o.rateUpCount,p=o.probability,u=new m(t,e,n.configSSR).runSteps(R),y=P(o,l,u,n.configWep.pointsSSR);r[f].push({cashback:y,probability:p})}for(let o=0;o<r.length;o++){const f=z(r[o]);r[o]=k(f)}return r}function d(a,e,t,s,n){const{combos:c,maxOffRateCount:R}=C(e,h),{combos:l,maxOffRateCount:b}=C(t,h),r=L(a,c,R,s),o=T(l,b,s,n);return B(r,o)}function L(a,e,t,s){const n=Math.max(...e.map(R=>R.rateUpCount)),c=[];for(const{rateUps:R,offRates:l,probability:b}of a){const o=new m(R,s.rateUpCharacterSR,s.configSR).runSteps(n),p=new m(l,s.poolCharSR-s.rateUpCharacterSR,s.configSR).runSteps(t),S=i(t,p,s.configWep.pointsSR,U),u=v(e,o,S);c.push({probability:b,cashback:u})}return k(c)}function T(a,e,t,s){const n=Math.max(...a.map(o=>o.rateUpCount)),c=r(n,t.configWep.pointsSR),l=new m(s.SR.consCount,t.poolCharSR,t.configSR).runSteps(e),b=i(e,l,t.configWep.pointsSR,U);return v(a,c,b);function r(o,f){return Array.from({length:o+1},(p,S)=>({mean:S*f,variance:0}))}}function z(a){let e=0;for(const t of a)e+=t.probability;for(const t of a)t.probability/=e;return a}export{D as c};

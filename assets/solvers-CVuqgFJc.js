class S{constructor({getPageConfiguration:t,getLabels:e,getPullPlan:i,getTarget:a,updateChart:s,convertToChartData:n,recalcInputs:l,calculatorFunction:o,calculatorConfig:c,pageConfig:p,postCalculationHooks:f,persistence:d,chibi:m}){this.getPageConfiguration=t,this.getLabels=e,this.getPullPlan=i,this.getTarget=a,this.updateChart=s,this.convertToChartData=n,this.recalcInputs=l,this.calculatorFunction=o,this.calculatorConfig=c,this.pageConfig=p,this.postCalculationHooks=f||[],this.persistence=d,this.chibi=m}async runCalculation(){const t=this.getTarget(),e=this.getPageConfiguration(this.calculatorConfig.CONSTELLATION_MAP,this.calculatorConfig.gachaConfig,this.pageConfig.SELECTORS,this.pageConfig.INITIAL_CONFIG),i=this.getLabels(this.calculatorConfig.gachaConfig.paths);if(i.length>99){this.chibi.showError("Too many items! Even I can't calculate so quickly, maximum 99 items allowed.");return}const a=await this.calculatorFunction(e,t),s=this.convertToChartData(a.chartData);this.updateChart(s.data,s.labels,i),this.recalcInputs(s.data);const n={results:a,inputConfig:e,chartLabels:i,gachaConfig:this.calculatorConfig.gachaConfig,CONSTELLATION_MAP:this.calculatorConfig.CONSTELLATION_MAP};if(this.postCalculationHooks.forEach(l=>l(n)),this.persistence){const l=parseInt(document.querySelector('[data-control="pulls"]').value),o=parseInt(document.querySelector('[data-control="probability"]').value);this.persistence.saveCalculation({input:this.getPullPlan(),targetProb:o,targetPull:l,persistInput:document.querySelector(".mode-label.active").getAttribute("data-target")}),this.persistence.saveButtons()}}}class C{constructor(t){this.constellationMap=t,this.availableConstellationCounts=[],this.isInitialized=!1}initialize(){if(this.isInitialized)return;const t=document.querySelectorAll('input[type="number"]');t.forEach(e=>{e.addEventListener("focus",()=>{e.select()})}),t.forEach(e=>{e.addEventListener("keydown",i=>{["Backspace","Delete","Tab","Escape","Enter","ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End"].includes(i.key)||(i.ctrlKey||i.metaKey)&&["a","c","v","x"].includes(i.key.toLowerCase())||/^\d$/.test(i.key)||i.preventDefault()})}),t.forEach(e=>{e.addEventListener("input",i=>{const a=i.target,s=a.closest("table");if(s)switch(s.id){case"constellation-table":{const n=a.closest("tr");n&&this.validateRowSum(n),this.updateAvailableCountsCache(),this.validateRateUpEligibility();break}case"rate-up-table":{this.validateRateUpEligibility();break}}})}),this.isInitialized=!0}validateAll(){document.querySelectorAll(".is-invalid").forEach(e=>e.classList.remove("is-invalid"));const t=document.querySelector("#constellation-table");t&&t.querySelectorAll("tbody tr").forEach(e=>this.validateRowSum(e))}getRateUpUsage(){const t=new Array(Object.keys(this.constellationMap).length).fill(0);return document.querySelectorAll("#rate-up-table select.custom-select").forEach(e=>{const i=this.constellationMap[e.value];i!==void 0&&t[i]++}),t}validateRowSum(t){if(!t.dataset.targetSum)return;const e=parseFloat(t.dataset.targetSum),i=t.querySelectorAll('input[type="number"]');let a=0;i.forEach(s=>a+=parseFloat(s.value)||0),i.forEach(s=>s.classList.toggle("is-invalid",a!==e))}isDataValid(){const t=document.querySelectorAll('#pity-table input[type="number"]');for(const i of t)if(!this.isIndividualInputValid(i))return!1;const e=document.querySelectorAll("#constellation-table tbody tr");for(const i of e)if(!this.isRowSumValid(i))return!1;return!this.isRateUpOverBudget()}isIndividualInputValid(t){if(t.value===""||/^\d+$/.test(t.value)){const e=parseInt(t.value,10),i=parseInt(t.min,10),a=parseInt(t.max,10);return(!t.hasAttribute("min")||e>=i)&&(!t.hasAttribute("max")||e<=a)}return!1}isRowSumValid(t){if(!t.dataset.targetSum)return!0;const e=parseFloat(t.dataset.targetSum),i=t.querySelectorAll('input[type="number"]');let a=0;return i.forEach(s=>a+=parseFloat(s.value)||0),a===e}isRateUpOverBudget(){const t=this.getRateUpUsage();return this.availableConstellationCounts.some((e,i)=>t[i]>e)}}function T(r,t){for(const e of r){const i=u(e.rateUps);if(!y(i,t)){e.probability=0;continue}const a=h(i,t),s=g(r,t);e.probability=s===0?0:a/s}}function u(r){const t={};for(let e=0;e<r.length;e++){const i=r[e];i>0&&(t[e]=i)}return t}function y(r,t){return Object.entries(r).every(([e,i])=>t[e]>=i)}function h(r,t){return Object.entries(r).reduce((e,[i,a])=>e*b(t[i],a),1)}function g(r,t){return r.reduce((e,i)=>{const a=u(i.rateUps),s=h(a,t);return e+s},0)}function b(r,t){if(t<0||t>r)return 0;if(t===0||t===r)return 1;t=Math.min(t,r-t);let e=1;for(let i=1;i<=t;i++)e*=(r-t+i)/i;return e}function v(r,t){if(!Number.isInteger(r)||r<0)throw new Error("Number of trials (n) must be a non-negative integer.");let e=0,i=0,a=[],s=1;for(;e<=r;)i=s*Math.pow(t,e)*Math.pow(1-t,r-e),a.push(i),e++,s=s*(r+1-e)/e;return a}class A{constructor(t,e,i){this.initialState=[...t],this.totalItems=e,this.config=i,this.maxType=i.maxType,this.nTypes=t.length,this.points=Array(this.nTypes).fill(0);for(let a=1;a<this.maxType;a++)this.points[a]=i.regularPoints;this.points[this.maxType]=i.specialPoints,this.reset()}reset(){this.expected=[...this.initialState],this.mean=0,this.secondMoment=0,this.variance=0,this.stateSecondMoments=Array(this.nTypes).fill(0).map(()=>Array(this.nTypes).fill(0));for(let t=0;t<this.nTypes;t++)for(let e=0;e<this.nTypes;e++)this.stateSecondMoments[t][e]=this.initialState[t]*this.initialState[e];this.pointStateCrossMoments=Array(this.nTypes).fill(0),this.results=[{mean:0,variance:0}],this.step=0}computeStep(){const t=this.totalItems;this.step++;let e=0,i=0;for(let o=0;o<this.nTypes;o++){const c=this.expected[o]/t;e+=this.points[o]*c,i+=this.points[o]**2*c}let a=0;for(let o=0;o<this.nTypes;o++)a+=this.points[o]*this.pointStateCrossMoments[o];a/=t;const s=this.secondMoment+2*a+i,n=this.mean+e,l=s-n**2;return this.results.push({mean:n,variance:l}),this.updateState(),this.secondMoment=s,this.mean=n,this.variance=l,{mean:n,variance:l,step:this.step}}updateState(){const t=this.totalItems,e=Array(this.nTypes).fill(0);for(let s=0;s<this.maxType;s++)e[s]=this.expected[s]*(t-1)/t;e[this.maxType]=this.expected[this.maxType];for(let s=0;s<this.maxType;s++)e[s+1]+=this.expected[s]/t;const i=Array(this.nTypes).fill(0).map(()=>Array(this.nTypes).fill(0));for(let s=0;s<this.nTypes;s++)for(let n=0;n<this.nTypes;n++)i[s][n]=this.stateSecondMoments[s][n];for(let s=0;s<this.maxType;s++){const n=Array(this.nTypes).fill(0);n[s]=-1,n[s+1]=1;for(let l=0;l<this.nTypes;l++)for(let o=0;o<this.nTypes;o++)i[l][o]+=1/t*(n[l]*this.stateSecondMoments[s][o]+n[o]*this.stateSecondMoments[l][s]+n[l]*n[o]*this.expected[s])}const a=Array(this.nTypes).fill(0);for(let s=0;s<this.nTypes;s++){let n=this.pointStateCrossMoments[s];s<this.maxType&&(n-=this.pointStateCrossMoments[s]/t),s>=1&&(n+=this.pointStateCrossMoments[s-1]/t);let l=0;for(let o=0;o<this.nTypes;o++)l+=this.points[o]*this.stateSecondMoments[s][o];n+=l/t,s<this.maxType&&(n-=this.points[s]*this.expected[s]/t),s>=1&&(n+=this.points[s-1]*this.expected[s-1]/t),a[s]=n}this.expected=e,this.stateSecondMoments=i,this.pointStateCrossMoments=a}runSteps(t){this.reset();for(let e=0;e<t;e++)this.computeStep();return this.results}}export{S as C,C as D,A as I,v as b,T as c};

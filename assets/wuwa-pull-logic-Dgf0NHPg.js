function _(n,r,o,E,l,i){const{charPullsSum:S,wepPullsSum:a}=L(n),c={characters:0,weapons:0},u={},h=n.length-2;for(let s=h;s>=0;s--){const t=n[s],f=i[s+1];if(!t.isEmpty)if(t.type==="Character")m(r,s,n,E,c,t.type,f);else if(t.type==="Weapon")m(o,s,n,l,c,t.type,f);else throw new Error(`Unknown SSR array type: ${t.type}`)}const{charRankUps:g,wepRankUps:U}=w(S,a,c);return u.charRankUps=g,u.wepRankUps=U,u;function L(s){const t={charPullsSum:0,wepPullsSum:0};if(s.length<=1)return t;const f=s.length-1;for(let R=0;R<f;R++){const{type:e,states:b}=s[R];let p=0;for(const P of b)for(const{prob:k}of P.values())p+=k;switch(e){case"Character":t.charPullsSum+=p;break;case"Weapon":t.wepPullsSum+=p;break}}return t}function w(s,t,f){let R=f.characters,e=f.weapons;return{charRankUps:{pullsSum:s,rankUps:R},wepRankUps:{pullsSum:t,rankUps:e}}}}function M(n,r,o,E){const l=n.length-1;for(let i=l;i>=0;i--)n[i].isEmpty||V(o,i,n,E,r)}function W(n,r,o,E,l,i){const S=n.length-2;for(let a=S;a>=0;a--){const c=n[a],u=i[a+1];if(!c.isEmpty)if(c.type==="Character")N(r,a,n,E,c.type,u);else if(c.type==="Weapon")N(o,a,n,l,c.type,u);else throw new Error(`Unknown SSR array type: ${c.type}`)}}function m(n,r,o,E,l,i,S){const a=o[r].states.length;let c=.5;const u=o[r].states,h=o[r+1].states;for(let g=a-2;g>=0;g--){const U=u[g];let L,w;i==="Weapon"?(L=!0,w=n[g]):(L=g>=E,w=n[g-E*L]);for(const[s,t]of U){const f=t.prob*w,R=t.prob-f;let e=f;if(e>1e-10){L||(e*=c);const p=h[S],P=p.get(s);P?P.prob+=e:p.set(s,{prob:e}),i==="Character"?l.characters+=e:i==="Weapon"&&(l.weapons+=e)}if(!L){let p=f*(1-c);if(p>1e-10){let P=s;i==="Character"?P+=100:i==="Weapon"&&P++;const k=u[E],y=k.get(P);y?y.prob+=p:k.set(P,{prob:p})}}let b=R;if(b>1e-10){const p=u[g+1],P=p.get(s);P?P.prob+=b:p.set(s,{prob:b})}t.prob=0}}}function V(n,r,o,E,l){const i=o[r].states.length,S=o[r].states;l.rankUpFail=l.pullsSum-l.rankUps;for(let a=i-1;a>=0;a--){const c=S[a],u=a>=E,h=n[a-E*u],g=.5;for(const[U,L]of c){const w=L.prob,s=w*l.pullsSum;if(s>1e-10){L.prob=w*(1-l.pullsSum);const t=w*h*l.rankUpFail,f=s*(1-h)*l.rankUpFail,R=w*l.rankUps;if(t>1e-10){let e=t;u||(e*=g),o[r+1]===void 0&&(o[r+1]={states:Array.from({length:o[r].states.length},()=>new Map)});const b=o[r+1].states[0],p=b.get(U);p?p.prob+=e:b.set(U,{prob:e})}if(!u){let e=t*(1-g);if(e>1e-10){let b=U+1;const p=S[E],P=p.get(b);P?P.prob+=e:p.set(b,{prob:e})}}if(f>1e-10){const e=S[a+1],b=e.get(U);b?b.prob+=f:e.set(U,{prob:f})}if(R>1e-10){const e=S[0],b=e.get(U);b?b.prob+=R:e.set(U,{prob:R})}}}}}function N(n,r,o,E,l,i){const S=o[r].states.length;let a=.5;const c=o[r].states,u=o[r+1].states;for(let h=S-2;h>=0;h--){const g=c[h];let U,L;l==="Weapon"?(U=!0,L=n[h]):(U=h>=E,L=n[h-E*U]);const w=g*L,s=g-w;let t=w;if(t>1e-10&&(U||(t*=a),u[i]+=t),!U){let R=w*(1-a);R>1e-10&&(c[E]+=R)}let f=s;f>1e-10&&(c[h+1]+=f),c[h]=0}}export{M as rankUpSR,_ as rankUpSSR,W as rankUpSSRCheap};

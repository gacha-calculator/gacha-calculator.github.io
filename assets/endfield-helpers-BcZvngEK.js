function a(t,p,f){const s=new Array(t.length-1);for(let n=f.minItem;n<=f.maxItem;n++){let e=0,o=t[n];if(t[n]!==null){let l=p[n].minIndex;for(let i=l;i<=p[n].maxIndex;i++)e+=o[i];s[n]=e}}if(t.length-3===f.maxItem)for(let n=t.length-2;n<t.length;n++){let e=0,o=t[n];if(t[n]!==null){for(let l=0;l<t[n].length;l++)e+=o[l];p[n].type!=="Double Target"?s[n]=e:s[n-1]+=e}}return s}function u(t){const p=new Array(t.length);for(let f=0;f<t.length;f++){let s=0;if(t[f]&&!t[f].isEmpty){const n=t[f].spark;for(const e of n)if(e&&!e.isEmpty)if(e.pity!==void 0)for(const o of e.pity)for(const l of o.values())s+=l.prob;else for(const o of e.values())s+=o.prob}p[f]=s}return p}function y(t,p){let s=0;if(t[0]&&t[0].spark!==void 0){for(let e=0;e<t.length-1;e++)if(t&&!t[e].isEmpty){for(const o of t[e].spark)if(o&&!o.isEmpty)for(const l of o.pity)for(const[i,c]of l)s+=c.prob}for(const e of t[t.length-1].spark)for(const[o,l]of e)s+=l.prob}if(Math.abs(s-1)>1e-5){const e=1/s;for(let o=0;o<t.length-1;o++)if(t[o]&&!t[o].isEmpty){for(const l of t[o].spark)if(l&&!l.isEmpty)for(const i of l.pity)for(const[c,r]of i)r.prob*=e}}p[0]=0}function m(t){let s=0;for(let e=0;e<t.length-1;e++)if(t[e]&&!t[e].isEmpty){for(const o of t[e].spark)if(o&&!o.isEmpty)for(const l of o.pity)for(const[i,c]of l)c.prob<=1e-10?l.delete(i):s+=c.prob}for(const e of t[t.length-1].spark)for(const[o,l]of e)s+=l.prob;if(Math.abs(s-1)>1e-5){const e=1/s;for(let o=0;o<t.length-1;o++)if(t[o]&&!t[o].isEmpty){for(const l of t[o].spark)if(l&&!l.isEmpty)for(const i of l.pity)for(const[c,r]of i)r.prob*=e}}}function k(t){let p=!0;for(let f=0;f<t.length-1;f++){const s=t[f];if(s){s.isEmpty=!0;for(const n of s.spark){if(!n)continue;n.isEmpty=!0;const e=n.pity;for(let o=0;o<e.length;o++){const l=e[o];for(let i=0;i<200;i++)if(l[i]>0){n.isEmpty=!1,s.isEmpty=!1,p=!1;break}if(!n.isEmpty)break}}}}return p}function h(t,p,f){if(p.type==="probability"){const s=t.length-1;let n=0;const e=t[s].spark[0];if(!e.isEmpty)for(let o=0;o<e.length;o++)n+=e[o];return n>p.value}else if(p.type==="pulls")return f===p.value}function g(t){let p=!1;for(let f=0;f<t.length;f++)if(t[f]){for(let s=0;s<t[f].spark.length;s++)if(!p){if(!t[f].spark[s])continue;if(t[f].spark[s].isEmpty)t[f].spark[s]=null;else{p=!0;continue}}p||(t[f]=null)}}function E(t){const p=[];for(let f=0;f<t.length-1;f++)if(t[f]){for(const s of t[f].spark)if(s){let n="None";f>0&&f<=t.length&&t[f-1]&&(n=t[f-1].type||"None");let e={offRates:new Map,type:n};if(s.pity!==void 0)for(const o of s.pity)for(const[l,i]of o){let c=Math.trunc(l/10);const r=e.offRates.get(c);r?r.prob+=i.prob:e.offRates.set(c,{prob:i.prob})}else for(const[o,l]of s){let i=Math.trunc(o/10);const c=e.offRates.get(i);c?c.prob+=l.prob:e.offRates.set(i,{prob:l.prob})}e.offRates.size>0&&p.push(e)}}return p}function S(t){for(const p of t)if(p){for(let f of p.spark)if(f){const s=f.pity;if(s!==void 0)for(let n=0;n<s.length;n++){const e=s[n],o=new Map;for(const[l,i]of e){const c=l%10,r=o.get(c);r?r.prob+=i.prob:o.set(c,{...i})}s[n]=o}else{const n=f,e=new Map;for(const[o,l]of n){const i=o/1e3*1e3%10,c=e.get(i);c?c.prob+=l.prob:e.set(i,{...l})}f=e}}}}export{k as checkIsEmpty,h as checkIsTarget,g as clearMaps,E as consolidateDistributionForCashback,a as consolidateProbabilities,u as consolidateProbabilitiesCheap,y as normalize,m as normalizeCheap,S as simplifyDistribution};

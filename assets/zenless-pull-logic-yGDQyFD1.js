function d(n,r,o,f,a,c){const{charPullsSum:L,wepPullsSum:p}=P(n),b={characters:0,weapons:0},E={},g=n.length-2;for(let s=g;s>=0;s--){const e=n[s],i=c[s+1];if(!e.isEmpty)if(e.type==="Character")V(r,s,n,f,b,e.type,i);else if(e.type==="Weapon")V(o,s,n,a,b,e.type,i);else throw new Error(`Unknown SSR array type: ${e.type}`)}const{charRankUps:S,wepRankUps:l}=w(L,p,b);return E.charRankUps=S,E.wepRankUps=l,E;function P(s){const e={charPullsSum:0,wepPullsSum:0};if(s.length<=1)return e;const i=s.length-1;for(let h=0;h<i;h++){const{type:t,states:U}=s[h];let u=0;for(const y of U)for(const{prob:R}of y.values())u+=R;switch(t){case"Character":e.charPullsSum+=u;break;case"Weapon":e.wepPullsSum+=u;break}}return e}function w(s,e,i){let h=i.characters,t=i.weapons;return{charRankUps:{pullsSum:s,rankUps:h},wepRankUps:{pullsSum:e,rankUps:t}}}}function M(n,r,o,f){const a=n.length-1;for(let c=a;c>=0;c--)n[c].isEmpty||_(o,c,n,f,r)}function O(n,r,o,f,a,c){const L=n.length-2;for(let p=L;p>=0;p--){const b=n[p],E=c[p+1];if(!b.isEmpty)if(b.type==="Character")W(r,p,n,f,b.type,E);else if(b.type==="Weapon")W(o,p,n,a,b.type,E);else throw new Error(`Unknown SSR array type: ${b.type}`)}}function V(n,r,o,f,a,c,L){const p=o[r].states.length,b=.5,E=.75;let g=.5;c==="Character"?g=b:c==="Weapon"&&(g=E);const S=o[r].states,l=o[r+1].states;for(let P=p-1;P>=0;P--){const w=S[P],s=P>=f,e=n[P-f*s];for(const[i,h]of w){const t=h.prob*e,U=h.prob-t;let u=t;if(u>1e-10){s||(u*=g);const R=l[L],k=R.get(i);k?k.prob+=u:R.set(i,{prob:u}),c==="Character"?a.characters+=u:c==="Weapon"&&(a.weapons+=u)}if(!s){let R=t*(1-g);if(R>1e-10){let k=i;c==="Character"?k+=100:c==="Weapon"&&k++;const m=S[f],N=m.get(k);N?N.prob+=R:m.set(k,{prob:R})}}let y=U;if(y>1e-10){const R=S[P+1],k=R.get(i);k?k.prob+=y:R.set(i,{prob:y})}h.prob=0}}}function _(n,r,o,f,a){const c=o[r].states.length,L=o[r].states;a.rankUpFail=a.pullsSum-a.rankUps;for(let p=c-1;p>=0;p--){const b=L[p],E=p>=f,g=n[p-f*E],S=.5;for(const[l,P]of b){const w=P.prob,s=w*a.pullsSum;if(s>1e-10){P.prob=w*(1-a.pullsSum);const e=w*g*a.rankUpFail,i=s*(1-g)*a.rankUpFail,h=w*a.rankUps;if(e>1e-10){let t=e;E||(t*=S),o[r+1]===void 0&&(o[r+1]={states:Array.from({length:o[r].states.length},()=>new Map)});const U=o[r+1].states[0],u=U.get(l);u?u.prob+=t:U.set(l,{prob:t})}if(!E){let t=e*(1-S);if(t>1e-10){let U=l+1;const u=L[f],y=u.get(U);y?y.prob+=t:u.set(U,{prob:t})}}if(i>1e-10){const t=L[p+1],U=t.get(l);U?U.prob+=i:t.set(l,{prob:i})}if(h>1e-10){const t=L[E*f],U=t.get(l);U?U.prob+=h:t.set(l,{prob:h})}}}}}function W(n,r,o,f,a,c){const L=o[r].states.length,p=.5,b=.75;let E=.5;a==="Character"?E=p:a==="Weapon"&&(E=b);const g=o[r].states,S=o[r+1].states;for(let l=L-1;l>=0;l--){const P=g[l],w=l>=f,s=n[l-f*w],e=P*s,i=P-e;let h=e;if(h>1e-10&&(w||(h*=E),S[c]+=h),!w){let U=e*(1-E);U>1e-10&&(g[f]+=U)}let t=i;t>1e-10&&(g[l+1]+=t),g[l]=0}}export{M as rankUpSR,d as rankUpSSR,O as rankUpSSRCheap};

function d(n,r,o,l,a,p){const{charPullsSum:P,wepPullsSum:c}=u(n),h={characters:0,weapons:0},U={},b=n.length-2;for(let s=b;s>=0;s--){const e=n[s],f=p[s+1];if(!e.isEmpty)if(e.type==="Character")N(r,s,n,l,h,e.type,f);else if(e.type==="Weapon")N(o,s,n,a,h,e.type,f);else throw new Error(`Unknown SSR array type: ${e.type}`)}const{charRankUps:S,wepRankUps:E}=L(P,c,h);return U.charRankUps=S,U.wepRankUps=E,U;function u(s){const e={charPullsSum:0,wepPullsSum:0};if(s.length<=1)return e;const f=s.length-1;for(let t=0;t<f;t++){const{type:i,states:w}=s[t];let g=0;for(const m of w)for(const{prob:R}of m.values())g+=R;switch(i){case"Character":e.charPullsSum+=g;break;case"Weapon":e.wepPullsSum+=g;break}}return e}function L(s,e,f){let t=f.characters,i=f.weapons;return{charRankUps:{pullsSum:s,rankUps:t},wepRankUps:{pullsSum:e,rankUps:i}}}}function O(n,r,o,l){const a=n.length-1;for(let p=a;p>=0;p--)n[p].isEmpty||_(o,p,n,l,r)}function M(n,r,o,l,a,p){const P=n.length-2;for(let c=P;c>=0;c--){const h=n[c],U=p[c+1];if(!h.isEmpty)if(h.type==="Character")V(r,c,n,l,h.type,U);else if(h.type==="Weapon")V(o,c,n,a,h.type,U);else throw new Error(`Unknown SSR array type: ${h.type}`)}}function N(n,r,o,l,a,p,P){const c=o[r].states.length,h=.5,U=.75;let b=.5;p==="Character"?b=h:p==="Weapon"&&(b=U);const S=o[r].states,E=o[r+1].states;for(let u=c-1;u>=0;u--){const L=S[u],s=u>=l,e=n[u-l*s];for(const[f,t]of L){const i=t.prob*e,w=t.prob-i;let g=i;if(g>1e-10){s||(g*=b);const R=E[P],k=R.get(f);k?k.prob+=g:R.set(f,{prob:g}),p==="Character"?a.characters+=g:p==="Weapon"&&(a.weapons+=g)}if(!s){let R=i*(1-b);if(R>1e-10){let k=f;p==="Character"?k+=100:p==="Weapon"&&k++;const y=S[l],W=y.get(k);W?W.prob+=R:y.set(k,{prob:R})}}let m=w;if(m>1e-10){const R=S[u+1],k=R.get(f);k?k.prob+=m:R.set(f,{prob:m})}t.prob=0}}}function _(n,r,o,l,a){const p=o[r].states.length,P=o[r].states;a.rankUpFail=a.pullsSum-a.rankUps;for(let c=p-1;c>=0;c--){const h=P[c],U=c>=l,b=n[c-l*U],S=.5;for(const[E,u]of h){const L=u.prob,s=L*a.pullsSum;if(s>1e-10){u.prob=L*(1-a.pullsSum);const e=L*b*a.rankUpFail,f=s*(1-b)+L*b*a.rankUps;if(e>1e-10){let t=e;U||(t*=S),o[r+1]===void 0&&(o[r+1]={states:Array.from({length:o[r].states.length},()=>new Map)});const i=o[r+1].states[0],w=i.get(E);w?w.prob+=t:i.set(E,{prob:t})}if(!U){let t=e*(1-S);if(t>1e-10){let i=E+1;const w=P[l],g=w.get(i);g?g.prob+=t:w.set(i,{prob:t})}}if(f>1e-10)if(c-l*U===l-1)u.prob+=s*b*a.rankUps;else{const t=P[c+1],i=t.get(E);i?i.prob+=f:t.set(E,{prob:f})}}}}}function V(n,r,o,l,a,p){const P=o[r].states.length,c=.5,h=.75;let U=.5;a==="Character"?U=c:a==="Weapon"&&(U=h);const b=o[r].states,S=o[r+1].states;for(let E=P-1;E>=0;E--){const u=b[E],L=E>=l,s=n[E-l*L],e=u*s,f=u-e;let t=e;if(t>1e-10&&(L||(t*=U),S[p]+=t),!L){let w=e*(1-U);w>1e-10&&(b[l]+=w)}let i=f;i>1e-10&&(b[E+1]+=i),b[E]=0}}export{O as rankUpSR,d as rankUpSSR,M as rankUpSSRCheap};

function c(e){const a=new Array(e.length);for(let o=0;o<e.length;o++){let n=0;if(!e[o].isEmpty){const r=e[o].spark;for(const t of r)if(!t.isEmpty)if(t.pity!==void 0)for(const f of t.pity)for(const s of f.values())n+=s.prob;else for(const f of t.values())n+=f.prob}a[o]=n}return a}function y(e){const a=new Array(e.length);for(let o=0;o<e.length;o++){let n=0;if(!e[o].isEmpty){const r=e[o].spark;for(const t of r)if(!t.isEmpty)if(t.pity!==void 0)for(const f of t.pity)for(const s of f.values())n+=s.prob;else for(const f of t.values())n+=f.prob}a[o]=n}return a}function u(e){let n=0;if(e[0].spark!==void 0){for(let t=0;t<e.length-1;t++)if(!e[t].isEmpty){for(const f of e[t].spark)if(!f.isEmpty)for(const s of f.pity)for(const[p,l]of s)l.prob<=1e-10?s.delete(p):n+=l.prob}for(const t of e[e.length-1].spark)for(const[f,s]of t)n+=s.prob}if(Math.abs(n-1)>1e-5){const t=1/n;for(let f=0;f<e.length-1;f++)if(!e[f].isEmpty){for(const s of e[f].spark)if(!s.isEmpty)for(const p of s.pity)for(const[l,i]of p)i.prob*=t}}}function k(e){let n=0;for(let t=0;t<e.length-1;t++)if(!e[t].isEmpty){for(const f of e[t].spark)if(!f.isEmpty)for(const s of f.pity)for(const[p,l]of s)l.prob<=1e-10?s.delete(p):n+=l.prob}for(const t of e[e.length-1].spark)for(const[f,s]of t)n+=s.prob;if(Math.abs(n-1)>1e-5){const t=1/n;for(let f=0;f<e.length-1;f++)if(!e[f].isEmpty){for(const s of e[f].spark)if(!s.isEmpty)for(const p of s.pity)for(const[l,i]of p)i.prob*=t}}}function b(e,a=null){for(let o=0;o<e.length-1;o++)if(!e[o].isEmpty)return!1;return!0}function m(e,a,o){if(a.type==="probability"){const n=e.length-1;let r=0;for(const t of e[n].spark)for(const[f,s]of t)r+=s.prob;return r>a.value}else if(a.type==="pulls")return o===a.value}function E(e){const a=[];if(e[0].spark!==void 0)for(let o=0;o<e.length;o++)for(const n of e[o].spark){let r="None";o>0&&o<=e.length&&e[o-1]&&(r=e[o-1].type||"None");let t={offRates:new Map,type:r};if(n.pity!==void 0)for(const f of n.pity)for(const[s,p]of f){let l=Math.trunc(s/10);const i=t.offRates.get(l);i?i.prob+=p.prob:t.offRates.set(l,{prob:p.prob})}else for(const[f,s]of n){let p=Math.trunc(f/10);const l=t.offRates.get(p);l?l.prob+=s.prob:t.offRates.set(p,{prob:s.prob})}t.offRates.size>0&&a.push(t)}else for(let o=0;o<e.length;o++){const n=e[o].states;let r="None";o>0&&o<=e.length&&e[o-1]&&(r=e[o-1].type||"None");let t={offRates:new Map,type:r};for(const f of n)for(const[s,p]of f){let l=s;const i=t.offRates.get(l);i?i.prob+=p.prob:t.offRates.set(l,{prob:p.prob})}t.offRates.size>0&&a.push(t)}return a}function S(e){for(const a of e)for(let o of a.spark){const n=o.pity;if(n!==void 0)for(let r=0;r<n.length;r++){const t=n[r],f=new Map;for(const[s,p]of t){const l=s%10,i=f.get(l);i?i.prob+=p.prob:f.set(l,{...p})}n[r]=f}else{const r=o,t=new Map;for(const[f,s]of r){const p=f/1e3*1e3%10,l=t.get(p);l?l.prob+=s.prob:t.set(p,{...s})}o=t}}}export{b as checkIsEmpty,m as checkIsTarget,E as consolidateDistributionForCashback,c as consolidateProbabilities,y as consolidateProbabilitiesCheap,k as normalizeCheap,u as pruneAndNormalize,S as simplifyDistribution};

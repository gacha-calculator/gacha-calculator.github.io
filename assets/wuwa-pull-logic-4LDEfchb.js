function _(n,r,o,i,l,f){const{charPullsSum:S,wepPullsSum:a}=L(n),c={characters:0,weapons:0},U={},h=n.length-2;for(let s=h;s>=0;s--){const t=n[s],E=f[s+1];if(!t.isEmpty)if(t.type==="Character")m(r,s,n,i,c,t.type,E);else if(t.type==="Weapon")m(o,s,n,l,c,t.type,E);else throw new Error(`Unknown SSR array type: ${t.type}`)}const{charRankUps:g,wepRankUps:b}=w(S,a,c);return U.charRankUps=g,U.wepRankUps=b,U;function L(s){const t={charPullsSum:0,wepPullsSum:0};if(s.length<=1)return t;const E=s.length-1;for(let R=0;R<E;R++){const{type:e,states:u}=s[R];let p=0;for(const P of u)for(const{prob:k}of P.values())p+=k;switch(e){case"Character":t.charPullsSum+=p;break;case"Weapon":t.wepPullsSum+=p;break}}return t}function w(s,t,E){let R=E.characters,e=E.weapons;return{charRankUps:{pullsSum:s,rankUps:R},wepRankUps:{pullsSum:t,rankUps:e}}}}function M(n,r,o,i){const l=n.length-1;for(let f=l;f>=0;f--)n[f].isEmpty||V(o,f,n,i,r)}function W(n,r,o,i,l,f){const S=n.length-2;for(let a=S;a>=0;a--){const c=n[a],U=f[a+1];if(!c.isEmpty)if(c.type==="Character")N(r,a,n,i,c.type,U);else if(c.type==="Weapon")N(o,a,n,l,c.type,U);else throw new Error(`Unknown SSR array type: ${c.type}`)}}function m(n,r,o,i,l,f,S){const a=o[r].states.length;let c=.5;const U=o[r].states,h=o[r+1].states;for(let g=a-2;g>=0;g--){const b=U[g];let L,w;f==="Weapon"?(L=!0,w=n[g]):(L=g>=i,w=n[g-i*L]);for(const[s,t]of b){const E=t.prob*w,R=t.prob-E;let e=E;if(e>1e-10){L||(e*=c);const p=h[S],P=p.get(s);P?P.prob+=e:p.set(s,{prob:e}),f==="Character"?l.characters+=e:f==="Weapon"&&(l.weapons+=e)}if(!L){let p=E*(1-c);if(p>1e-10){let P=s;f==="Character"?P+=100:f==="Weapon"&&P++;const k=U[i],y=k.get(P);y?y.prob+=p:k.set(P,{prob:p})}}let u=R;if(u>1e-10){const p=U[g+1],P=p.get(s);P?P.prob+=u:p.set(s,{prob:u})}t.prob=0}}}function V(n,r,o,i,l){const f=o[r].states.length,S=o[r].states;l.rankUpFail=l.pullsSum-l.rankUps;for(let a=f-1;a>=0;a--){const c=S[a],U=a>=i,h=n[a-i*U],g=.5;for(const[b,L]of c){const w=L.prob,s=w*l.pullsSum;if(s>1e-10){L.prob=w*(1-l.pullsSum);const t=w*h*l.rankUpFail,E=s*(1-h)*l.rankUpFail,R=w*l.rankUps;if(t>1e-10){let e=t;U||(e*=g),o[r+1]===void 0&&(o[r+1]={states:Array.from({length:o[r].states.length},()=>new Map)});const u=o[r+1].states[0],p=u.get(b);p?p.prob+=e:u.set(b,{prob:e})}if(!U){let e=t*(1-g);if(e>1e-10){let u=b+1;const p=S[i],P=p.get(u);P?P.prob+=e:p.set(u,{prob:e})}}if(E>1e-10){const e=S[a+1],u=e.get(b);u?u.prob+=E:e.set(b,{prob:E})}if(R>1e-10){const e=S[U*i],u=e.get(b);u?u.prob+=R:e.set(b,{prob:R})}}}}}function N(n,r,o,i,l,f){const S=o[r].states.length;let a=.5;const c=o[r].states,U=o[r+1].states;for(let h=S-2;h>=0;h--){const g=c[h];let b,L;l==="Weapon"?(b=!0,L=n[h]):(b=h>=i,L=n[h-i*b]);const w=g*L,s=g-w;let t=w;if(t>1e-10&&(b||(t*=a),U[f]+=t),!b){let R=w*(1-a);R>1e-10&&(c[i]+=R)}let E=s;E>1e-10&&(c[h+1]+=E),c[h]=0}}export{M as rankUpSR,_ as rankUpSSR,W as rankUpSSRCheap};

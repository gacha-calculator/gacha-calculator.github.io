function H(e){const a=new Array(e.length);for(let t=0;t<e.length;t++){let n=0;const c=e[t].states;for(let s=0;s<c.length;s++){const _=c[s];for(const o of _.values())n+=o.prob}a[t]=n}return a}function h(e){const a=new Array(e.length);for(let t=0;t<e.length;t++){let n=0;const c=e[t].states;for(let s=0;s<c.length;s++){const _=c[s];for(const o of _.values())n+=o.prob}a[t]=n}return a}function N(e){let s=0;for(let o=0,E=e.length;o<E;o++){const f=e[o].states;for(let r=0,L=f.length;r<L;r++)if(Array.isArray(f[r]))for(let l of f[r])for(const[u,p]of l){let i=1e-10;(l.size>=1e3||l.size>=100)&&(i=1e-10),p.prob<=i?l.delete(u):s+=p.prob}else{const l=f[r];for(const[u,p]of l){let i=1e-10;(l.size>=1e3||l.size>=100)&&(i=1e-10),p.prob<=i?l.delete(u):s+=p.prob}}}if(Math.abs(s-1)>1e-5){const o=1/s;for(let E=0,f=e.length;E<f;E++){const r=e[E].states;for(let L=0,l=r.length;L<l;L++){const u=r[L];for(const p of u.values())p.prob*=o}}}}function R(e){let s=0;for(let o=0,E=e.length;o<E;o++){const f=e[o].states;for(let r=0,L=f.length;r<L;r++)if(Array.isArray(f[r]))for(let l of f[r])for(const[u,p]of l){let i=1e-10;(l.size>=1e3||l.size>=100)&&(i=1e-10),p.prob<=i?l.delete(u):s+=p.prob}else{const l=f[r];for(const[u,p]of l){let i=1e-10;(l.size>=1e3||l.size>=100)&&(i=1e-10),p.prob<=i?l.delete(u):s+=p.prob}}}if(Math.abs(s-1)>1e-5){const o=1/s;for(let E=0,f=e.length;E<f;E++){const r=e[E].states;for(let L=0,l=r.length;L<l;L++){const u=r[L];for(const p of u.values())p.prob*=o}}}}function m(e,a){let t=!0;for(let n=0;n<e.length-1;n++){let c=!0;for(const s of e[n].states)s.size>0&&(c=!1,t=!1);e[n].isEmpty=c}return t}function b(e,a,t){if(a.type==="probability"){const n=e.length-1;let c=0;for(const s of e[n].states)for(const[_,o]of s)c+=o.prob;return c>a.value}else if(a.type==="pulls")return t===a.value}function g(e){const a=[];for(let t=0;t<e.length;t++){const n=e[t].states;let c="None";t>0&&t<=e.length&&e[t-1]&&(c=e[t-1].type||"None");let s={offRates:new Map,type:c};for(const _ of n)for(const[o,E]of _){let f;e[t].states.length===10?f=o:f=Math.trunc(o/1e4);const r=s.offRates.get(f);r?r.prob+=E.prob:s.offRates.set(f,{prob:E.prob})}a.push(s)}return a}function y(e){for(let a=0;a<e.length;a++){const t=e[a].states;for(let n=0;n<t.length;n++){const c=t[n],s=new Map;for(const[_,o]of c){const E=_%1e4,f=s.get(E);f?f.prob+=o.prob:s.set(E,{...o})}t[n]=s}}}export{m as checkIsEmpty,b as checkIsTarget,g as consolidateDistributionForCashback,H as consolidateProbabilities,h as consolidateProbabilitiesCheap,R as normalizeCheap,N as pruneAndNormalize,y as simplifyDistribution};

function z(P,s,o,p,V,L){const{charPullsSum:h,wepPullsSum:c}=f(P),U={characters:0,weapons:0},u={charLoss:null,wepLoss:null},g=P.length-2;for(let t=g;t>=0;t--){const n=L[t+1],E=n.pity;let S=null;n.type==="firstChar"&&(S=n.special);for(let r=0;r<4;r++){const e=P[t][r];if(!e.isEmpty)if(e.type==="Character")W(s,t,P,p,U,E,r);else if(e.type==="Weapon")m(o,t,P,V,U,E,r,S);else throw new Error(`Unknown SSR array type: ${e.type}`)}}const{charRankUps:a,wepRankUps:l}=b(h,c,U);return u.charLoss=a,u.wepLoss=l,u;function f(t){const n={charPullsSum:0,wepPullsSum:0};if(t.length<=1)return n;const E=t.length-1,S=t[0].length;for(let r=0;r<E;r++){let e=0;const i=t[r][0].type;for(let R=0;R<S;R++){const{states:w}=t[r][R];for(const _ of w)for(const{prob:N}of _.values())e+=N}switch(i){case"Character":n.charPullsSum+=e;break;case"Weapon":n.wepPullsSum+=e;break}}return n}function b(t,n,E){return{charRankUps:t-E.characters,wepRankUps:n-E.weapons}}}function A(P,s,o,p){const V=P.length-1;for(let L=V;L>=0;L--)P[L].isEmpty||C(o,L,P,p,s)}function G(P,s,o,p,V,L){const h=P.length-2;for(let c=h;c>=0;c--){const U=L[c+1],u=U.pity;let g=null;U.type==="firstChar"&&(g=U.special);for(let a=0;a<4;a++){const l=P[c][a];if(!l.isEmpty)if(l.type==="Character")k(s,c,P,p,u,a);else if(l.type==="Weapon")x(o,c,P,V,u,a,g);else throw new Error(`Unknown SSR array type: ${l.type}`)}}}function W(P,s,o,p,V,L,h){const c=Math.floor(h/2),U=o[s][h].states;if(h!=3){const u=o[s][h].states.length;let g=.5;h===2&&(g=.55);const a=o[s+1][c].states,l=o[s+1][h+1].states;for(let f=u-2;f>=0;f--){const b=U[f],t=f>=p,n=P[f-p*t];for(const[E,S]of b){const r=S.prob*n,e=S.prob-r;let i=r;if(i>1e-10){let w=l;t||(i*=g,w=a);const _=w[L],N=_.get(E);N?N.prob+=i:_.set(E,{prob:i}),V.characters+=i}if(!t){let w=r*(1-g);if(w>1e-10){let _=E+100;const N=U[p],y=N.get(_);y?y.prob+=w:N.set(_,{prob:w})}}let R=e;if(R>1e-10){const w=U[f+1],_=w.get(E);_?_.prob+=R:w.set(E,{prob:R})}S.prob=0}}}else{const u=o[s+1][c].states,g=o[s][h].states.length;for(let a=g-2;a>=0;a--){const l=U[a],f=P[a];for(const[b,t]of l){const n=t.prob*f,E=t.prob-n;let S=n;if(S>1e-10){const e=u[L],i=e.get(b);i?i.prob+=S:e.set(b,{prob:S}),V.characters+=S}let r=E;if(r>1e-10){const e=U[a+1],i=e.get(b);i?i.prob+=r:e.set(b,{prob:r})}t.prob=0}}}}function m(P,s,o,p,V,L,h,c){let U=h;c!=null&&(U=c);const u=o[s][h].states.length,g=.375,a=.625,l=o[s][h].states,f=o[s+1][U].states;for(let b=u-2;b>=0;b--){const t=l[b],n=b>=2*p;let E=!1;n||(E=b>=p);const S=P[b-p*E-p*n*2];for(const[r,e]of t){const i=e.prob*S,R=e.prob-i;let w=i;if(w>1e-10){n||(E?w*=a:w*=g);const N=f[L],y=N.get(r);y?y.prob+=w:N.set(r,{prob:w}),V.weapons+=w}if(!n){let N=i*(1-g);if(E&&(N=i*(1-a)),N>1e-10){let y=r+1;const M=l[p*2],O=M.get(y);O?O.prob+=N:M.set(y,{prob:N})}}let _=R;if(_>1e-10){const N=l[b+1],y=N.get(r);y?y.prob+=_:N.set(r,{prob:_})}e.prob=0}}}function C(P,s,o,p,V){const L=o[s].states.length,h=o[s].states;for(let c=L-1;c>=0;c--){const U=h[c],u=c>=p,g=P[c-p*u],a=.5;for(const[l,f]of U){const b=f.prob,t=b*V,n=b-t;if(f.prob=n,t>1e-10){const E=t*g,S=t-E;let r=E;if(r>1e-10){u||(r*=a),o[s+1]===void 0&&(o[s+1]={states:Array.from({length:o[s].states.length},()=>new Map)});const i=o[s+1].states[0],R=i.get(l);R?R.prob+=r:i.set(l,{prob:r})}if(!u){let i=E*(1-a);if(i>1e-10){let R=l;R++;const w=h[p],_=w.get(R);_?_.prob+=i:w.set(R,{prob:i})}}let e=S;if(e>1e-10){const i=h[c+1],R=i.get(l);R?R.prob+=e:i.set(l,{prob:e})}}}}}function k(P,s,o,p,V,L){const h=Math.floor(L/2),c=o[s][L].states;if(L!=3){const U=o[s][L].states.length;let u=.5;L===2&&(u=.55);const g=o[s+1][h].states,a=o[s+1][L+1].states;for(let l=U-2;l>=0;l--){const f=c[l],b=l>=p,t=P[l-p*b],n=f*t,E=f-n;let S=n;if(S>1e-10){let e=a;b||(S*=u,e=g),e[V]+=S}if(!b){let e=n*(1-u);e>1e-10&&(c[p]+=e)}let r=E;r>1e-10&&(c[l+1]+=r),c[l]=0}}else{const U=o[s+1][h].states,u=o[s][L].states.length;for(let g=u-2;g>=0;g--){const a=c[g],l=P[g],f=a*l,b=a-f;let t=f;t>1e-10&&(U[V]+=t);let n=b;n>1e-10&&(c[g+1]+=n),c[g]=0}}}function x(P,s,o,p,V,L,h){let c=L;h!=null&&(c=h);const U=o[s][L].states.length,u=.375,g=.625,a=o[s][L].states,l=o[s+1][c].states;for(let f=U-2;f>=0;f--){const b=a[f],t=f>=2*p;let n=!1;t||(n=f>=p);const E=P[f-p*n-p*t*2],S=b*E,r=b-S;let e=S;if(e>1e-10&&(t||(n?e*=g:e*=u),l[V]+=e),!t){let R=S*(1-u);n&&(R=S*(1-g)),R>1e-10&&(a[p*2]+=R)}let i=r;i>1e-10&&(a[f+1]+=i),a[f]=0}}export{A as rankUpSR,z as rankUpSSR,G as rankUpSSRCheap};

function u(s){let n=0;if(Array.isArray(s[0])){for(const e of s)for(let t=0;t<4;t++){const o=e[t].states;for(const a of o)for(const[f,r]of a)r.prob<=1e-10&&(n+=r.prob,a.delete(f))}if(n>0){const e=1/(1-n);for(const t of s)for(let o=0;o<4;o++){const a=t[o].states;for(const f of a)for(const[r,p]of f)p.prob*=e}}}else{for(const e of s){const t=e.states;for(const o of t)for(const[a,f]of o)f.prob<=1e-10&&(n+=f.prob,o.delete(a))}if(n>0){const e=1/(1-n);for(const t of s){const o=t.states;for(const a of o)for(const[f,r]of a)r.prob*=e}}}}function i(s,c){let l=!0;const n=4;if(c)for(let e=0;e<s.length-1;e++){let t=!0;for(let o=0;o<n;o++)for(const a of s[e][o].states)a>0&&(t=!1,l=!1);s[e].isEmpty=t}else for(let e=0;e<s.length-1;e++){let t=!0;for(let o=0;o<n;o++){for(const a of s[e][o].states)a.size>0&&(t=!1,l=!1);s[e][o].isEmpty=t}}return l}function R(s){const c=[];if(Array.isArray(s[0]))for(let e=0;e<s.length;e++){let t="None";e>0&&e<=s.length&&s[e-1]&&(t=s[e-1][0].type||"None");let o={offRates:new Map,type:t};for(let a=0;a<4;a++){const f=s[e][a].states;for(const r of f)r.size>0&&l(o.offRates,r)}c.push(o)}else for(let n=0;n<s.length;n++){const e=s[n].states;let t="None";n>0&&n<=s.length&&s[n-1]&&(t=s[n-1].type||"None");let o={offRates:new Map,type:t};for(const a of e)a.size>0&&l(o.offRates,a);c.push(o)}return c;function l(n,e){for(const[t,o]of e)n.has(t)?n.get(t).prob+=o.prob:n.set(t,{...o})}}function h(s){const c=new Array(s.length),l=4;for(let n=0;n<s.length;n++){let e=0;for(let t=0;t<l;t++){const o=s[n][t].states;for(let a=0;a<o.length;a++)e+=o[a]}c[n]=e}return c}function m(s){const c=[];for(let l=0;l<s.length;l++){const n=s[l];let e=0;for(let t=0;t<n.length;t++){const o=n[t].states;for(let a=0;a<o.length;a++)for(const[f,r]of o[a])e+=r.prob}c.push(e)}return c}function y(s){let n=0;for(let e=0,t=s.length;e<t;e++)for(let o=0;o<4;o++){const a=s[e][o].states;for(let f=0,r=a.length;f<r;f++)a[f]>0&&a[f]<=1e-10&&(n+=a[f],a[f]=0)}if(n>0){const e=1/(1-n);for(let t=0,o=s.length;t<o;t++)for(let a=0;a<4;a++){const f=s[t][a].states;for(let r=0,p=f.length;r<p;r++)f[r]!=0&&(f[r]*=e)}}}function E(s){for(let l=0;l<s.length;l++)for(let n=0;n<4;n++){const e=s[l][n].states;for(let t=0;t<e.length;t++){const o=e[t];let a=0;for(const f of o.values())a+=f.prob;e[t]=a}}}function d(s,c,l){if(c.type==="probability"){const n=s.length-1,e=s[n];let t=0;for(let o=0;o<e.length;o++)for(const a of e[o].states)for(const[f,r]of a)t+=r.prob;return t>c.value}else if(c.type==="pulls")return l===c.value}export{i as checkIsEmpty,d as checkIsTarget,R as consolidateDistributionForCashback,m as consolidateProbabilities,h as consolidateProbabilitiesCheap,y as normalizeCheap,u as pruneAndNormalize,E as simplifyDistribution};

function i(s){const f=new Array(s.length);for(let l=0;l<s.length;l++){let e=0;const o=s[l].states;for(let t=0;t<o.length;t++){const n=o[t];for(const a of n.values())e+=a.prob}f[l]=e}return f}function h(s){const f=new Array(s.length);for(let l=0;l<s.length;l++){let e=0;const o=s[l].states;for(let t=0;t<o.length;t++)e+=o[t];f[l]=e}return f}function m(s){let l=0;for(let e=0,o=s.length;e<o;e++){const t=s[e].states;for(let n=0,a=t.length;n<a;n++)if(Array.isArray(t[n]))for(let r of t[n])for(const[p,c]of r)c.prob<=1e-10&&(l+=c.prob,r.delete(p));else{const r=t[n];for(const[p,c]of r)c.prob<=1e-10&&(l+=c.prob,r.delete(p))}}if(l>0){const e=1/(1-l);for(let o=0,t=s.length;o<t;o++){const n=s[o].states;for(let a=0,r=n.length;a<r;a++){const p=n[a];for(const[c,u]of p)u.prob*=e}}}}function y(s){let l=0;for(let e=0,o=s.length;e<o;e++){const t=s[e].states;for(let n=0,a=t.length;n<a;n++)t[n]>0&&t[n]<=1e-10&&(l+=t[n],t[n]=0)}if(l>0){const e=1/(1-l);for(let o=0,t=s.length;o<t;o++){const n=s[o].states;for(let a=0,r=n.length;a<r;a++)n[a]!=0&&(n[a]*=e)}}}function E(s,f){let l=!0;if(f)for(let e=0;e<s.length-1;e++){let o=!0;for(const t of s[e].states)t>0&&(o=!1,l=!1);s[e].isEmpty=o}else for(let e=0;e<s.length-1;e++){let o=!0;for(const t of s[e].states)t.size>0&&(o=!1,l=!1);s[e].isEmpty=o}return l}function g(s,f,l){if(f.type==="probability"){const e=s.length-1;let o=0;for(const t of s[e].states)for(const[n,a]of t)o+=a.prob;return o>f.value}else if(f.type==="pulls")return l===f.value}function b(s){const f=[];for(let e=0;e<s.length;e++){const o=s[e].states;let t="None";e>0&&e<=s.length&&s[e-1]&&(t=s[e-1].type||"None");let n={offRates:new Map,type:t};for(const a of o)a.size>0&&l(n.offRates,a);f.push(n)}return f;function l(e,o){for(const[t,n]of o)e.has(t)?e.get(t).prob+=n.prob:e.set(t,{...n})}}function L(s){for(let f=0;f<s.length;f++){const l=s[f].states;for(let e=0;e<l.length;e++){const o=l[e];let t=0;for(const n of o.values())t+=n.prob;l[e]=t}}}export{i as a,h as b,E as c,b as d,g as e,y as n,m as p,L as s};

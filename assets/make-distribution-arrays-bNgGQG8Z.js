function l(t,a,S){if(!Array.isArray(t.SSR.pullPlan))throw new Error("Invalid pull plan");const{pullPlan:i}=t.SSR,e=[];for(const[s,p]of i.entries())p.type==="char"?e.push({states:Array.from({length:S.CHARACTER},()=>new Map),type:"Character",isEmpty:!0}):e.push({states:Array.from({length:S.WEAPON},()=>new Map),type:"Weapon",isEmpty:!0});return e.push({states:Array.from({length:1},()=>new Map)}),n(a),{distributionSSR:e};function n(s){e[0].states[s[0]].set(0,{prob:1}),e[0].isEmpty=!1}}function y(t,a){const S=a.pitySSRChar,i=a.pitySSRWep;let e=!1,n=!1,s=0,p=0;const r=[];s+=t.SSR.pity.char,s+=t.SSR.guarantee.char*S,p+=t.SSR.pity.wep,p+=t.SSR.guarantee.wep*i;for(const o of t.SSR.pullPlan)o.type==="char"&&!e?(e=!0,r.push(s)):o.type==="wep"&&!n?(n=!0,r.push(p)):r.push(0);return r.push(0),r}function c(t,a){const i=(a.SR-1)/2,e=[{states:Array.from({length:a.SR},()=>new Map)}],n=[{states:Array.from({length:a.SR},()=>new Map)}],s=t.SR.guarantee.char*i+t.SR.pity.char,p=t.SR.guarantee.wep*i+t.SR.pity.wep;r(e[0].states[s]),r(n[0].states[p]);function r(o){o.set(0,{prob:1})}return{distributionCharSR:e,distributionWepSR:n}}export{l as a,c as m,y as s};

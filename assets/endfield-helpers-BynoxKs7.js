function u(t,i){const f=new Array(t.length-1);for(let n=0;n<t.length;n++){let o=0;if(t[n].distribution!==null){for(let e=0;e<t[n].distribution.length;e++)o+=t[n].distribution[e];t[n].type!=="Double Target"?f[n]=o:f[n-1]+=o}}const s=20;for(let n=0;n<s;n++){let o=0;for(let e=n;e<t[t.length-2].distribution.length;e+=s)o+=t[t.length-2].distribution[e],t[t.length-2].distribution[e]=0;t[t.length-2].distribution[n]=o}return f}function a(t){const i=new Array(t.length);for(let f=0;f<t.length;f++){let s=0;if(t[f]&&!t[f].isEmpty){const n=t[f].spark;for(const o of n)if(o&&!o.isEmpty)if(o.pity!==void 0)for(const e of o.pity)for(const l of e.values())s+=l.prob;else for(const e of o.values())s+=e.prob}i[f]=s}return i}function k(t,i){let s=0;if(t[0]&&t[0].spark!==void 0){for(let o=0;o<t.length-1;o++)if(t&&!t[o].isEmpty){for(const e of t[o].spark)if(e&&!e.isEmpty)for(const l of e.pity)for(const[p,c]of l)s+=c.prob}for(const o of t[t.length-1].spark)for(const[e,l]of o)s+=l.prob}if(Math.abs(s-1)>1e-5){const o=1/s;for(let e=0;e<t.length-1;e++)if(t[e]&&!t[e].isEmpty){for(const l of t[e].spark)if(l&&!l.isEmpty)for(const p of l.pity)for(const[c,r]of p)r.prob*=o}}i[0]=0}function b(t){let s=0;for(let o=0;o<t.length-1;o++)if(t[o]&&!t[o].isEmpty){for(const e of t[o].spark)if(e&&!e.isEmpty)for(const l of e.pity)for(const[p,c]of l)c.prob<=1e-10?l.delete(p):s+=c.prob}for(const o of t[t.length-1].spark)for(const[e,l]of o)s+=l.prob;if(Math.abs(s-1)>1e-5){const o=1/s;for(let e=0;e<t.length-1;e++)if(t[e]&&!t[e].isEmpty){for(const l of t[e].spark)if(l&&!l.isEmpty)for(const p of l.pity)for(const[c,r]of p)r.prob*=o}}}function y(t){let i=!0;for(let f=0;f<t.length-1;f++){const s=t[f];if(s){s.isEmpty=!0;for(const n of s.spark){if(!n)continue;n.isEmpty=!0;const o=n.pity;for(let e=0;e<o.length;e++){const l=o[e];for(let p=0;p<200;p++)if(l[p]>0){n.isEmpty=!1,s.isEmpty=!1,i=!1;break}if(!n.isEmpty)break}}}}return i}function h(t,i,f){if(i.type==="probability"){const s=t.length-1;let n=0;const o=t[s].spark[0];if(!o.isEmpty)for(let e=0;e<o.length;e++)n+=o[e];return n>i.value}else if(i.type==="pulls")return f===i.value}function g(t){let i=!1;for(let f=0;f<t.length;f++)if(t[f]){for(let s=0;s<t[f].spark.length;s++)if(!i){if(!t[f].spark[s])continue;if(t[f].spark[s].isEmpty)t[f].spark[s]=null;else{i=!0;continue}}i||(t[f]=null)}}function m(t){const i=[];for(let f=0;f<t.length-1;f++)if(t[f]){for(const s of t[f].spark)if(s){let n="None";f>0&&f<=t.length&&t[f-1]&&(n=t[f-1].type||"None");let o={offRates:new Map,type:n};if(s.pity!==void 0)for(const e of s.pity)for(const[l,p]of e){let c=Math.trunc(l/10);const r=o.offRates.get(c);r?r.prob+=p.prob:o.offRates.set(c,{prob:p.prob})}else for(const[e,l]of s){let p=Math.trunc(e/10);const c=o.offRates.get(p);c?c.prob+=l.prob:o.offRates.set(p,{prob:l.prob})}o.offRates.size>0&&i.push(o)}}return i}function E(t){for(const i of t)if(i){for(let f of i.spark)if(f){const s=f.pity;if(s!==void 0)for(let n=0;n<s.length;n++){const o=s[n],e=new Map;for(const[l,p]of o){const c=l%10,r=e.get(c);r?r.prob+=p.prob:e.set(c,{...p})}s[n]=e}else{const n=f,o=new Map;for(const[e,l]of n){const p=e/1e3*1e3%10,c=o.get(p);c?c.prob+=l.prob:o.set(p,{...l})}f=o}}}}export{y as checkIsEmpty,h as checkIsTarget,g as clearMaps,m as consolidateDistributionForCashback,u as consolidateProbabilities,a as consolidateProbabilitiesCheap,k as normalize,b as normalizeCheap,E as simplifyDistribution};
